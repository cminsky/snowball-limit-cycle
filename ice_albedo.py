import numpy as np
from scipy.interpolate import interp1d
from scipy.interpolate import RBFInterpolator
from scipy.optimize import root_scalar

# --- albedo function ---

def albedo_scalar(T,
                  Ti=260, # ice-covered threshold temperature [K]
                  To=295, # ice-free threshold temperature [K]
                  ai=0.6, # ice-covered albedo
                  ao=0.28 # ice-free albedo
                 ):
    if T <= Ti:
        return ai
    elif T < To:
        return ao + (ai - ao) * (T - To)**2 / (Ti - To)**2
    else:
        return ao

albedo = np.vectorize(albedo_scalar)

# --- equilibrium temp ---

# Load data generated by PCM_LBL
data = np.load("forcing_arr.npz")
CO2_data = data['CO2']
albedo_data = data['albedo']
T_data = data['T']

# compute interpolator
log_pCO2 = np.log(CO2_data)
points = np.column_stack((log_pCO2, albedo_data))
interpolator = RBFInterpolator(points, T_data, kernel='quintic', smoothing=1.0)

# function to get temperature
get_T = lambda pCO2, albedo: interpolator(np.array([[np.log(pCO2), albedo]]))[0]

# --- solving for initial conditions ----

def get_conditions(T,
                   Ti=260, To=295, ai=0.6, ao=0.28,
                   pCO2_min=1, pCO2_max=1e6, verbose=False):
    # calculate albedo
    albedo_stable = albedo(T, Ti=Ti, To=To, ai=ai, ao=ao)
    
    # residual function
    def residual(pCO2):
        return get_T(pCO2, albedo_stable) - T
    
    # evaluate at endpoints
    fa = residual(pCO2_min)
    fb = residual(pCO2_max)
    
    # check if the values have opposite signs
    if fa * fb > 0:
        raise ValueError(f"No sign change in the bracket:\nf(pCO2_min) = {fa:0.0f}, f(pCO2_max) = {fb:0.0f}. ")
    
    # solve for pCO2 such that residual(pCO2) = 0
    pCO2_solution = root_scalar(residual, bracket=[pCO2_min, pCO2_max], method='brentq')
    
    if pCO2_solution.converged:
        pCO2 = pCO2_solution.root
        if verbose:
            print(f"pCO2 = {pCO2:0.0f} ppm")
            print(f"albedo = {albedo_stable:0.2f}")
        return pCO2, albedo_stable
    else:
        raise RuntimeError(f"Root finding did not converge for T = {T:0.0f}")

# --- carbonate chemistry ---

# constants
Na = 1.8e20             # moles air in atmosphere
Voc = Moc = 1.37e21     # ocean volume [L] and mass [kg]

# Henry's law constants for pH calc
KH = 3e-2 # Henry's law constant [M/atm]
K1 = 9e-7 # First acid dissociation constant (pK1 = 6.1) [M]
K2 = 7e-10 # Second acid dissociation constant (pK2 = 9.2) [M]

## fraction of CO2 (including as HCO2 and CO3) in the atmosphere
# Jacob textbook equation 6.8 page 97
def F_fn(pH):
        H = 10**(-pH) # [H+] in M
        fr = 1 + K1/H + K1*K2/(H**2) # captures fractionation of C into H2CO3, HCO3, and CO3
        coeff = Voc*1*KH/Na # pressure = 1 atm
        return 1/(1+coeff*fr)
    
## fraction of new CO2 that stays in the atmosphere
# Jacob textbook equation 6.18 page 100
def f_fn(pH):
        H = 10**(-pH) # [H+] in M
        beta = 1 + 4*K2/H # bottom of page 99
        num = Voc*1*KH*K1*K2 # pressure = 1 atm
        denom = Na*beta*H**2
        return 1/(1+num/denom)
    
# quadratic equation
quad_solver = lambda a,b,c: (-b + (b**2 - 4*a*c)**0.5) / (2*a) if a != 0 else None
    
# solving F equation for H and then converting to pH
def pH_fn(F):
    if F >= F_fn(0):
        return 0
    a = (1/F-1)/(Voc*1*KH/Na) - 1 # pressure = 1 atm
    H = quad_solver(a,-K1,-K1*K2)
    return -np.log10(H)